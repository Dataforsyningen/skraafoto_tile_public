import math
import time
import sys

from fastapi import FastAPI, Query, Path, Response, Request, HTTPException
from fastapi.param_functions import Depends
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.exception_handlers import http_exception_handler

from asyncio.exceptions import TimeoutError

from aiocogdumper.cog_tiles import COGTiff, Overflow
from aiocogdumper.errors import HTTPError, TIFFError, HTTPRangeNotSupportedError
from aiocogdumper.cog_tiles import TiffInfo
from settings import Settings

from loguru import logger

from cog import (
    HttpCogClient,
    CogRequest,
)

# Setup of settings and log
settings = Settings()
logger.remove()
logger.add(
    sys.stdout,
    colorize=settings.debug,
    format="<green>{time:HH:mm:ss}</green> | {level} | <level>{message}</level>",
    level="DEBUG" if settings.debug else "INFO",
)
logger.info(f"Starting API using settings: {settings}")

# Instantiate app
app = FastAPI()
cog_client = HttpCogClient(timeout=settings.request_timeout)


# Logging as middleware
@app.middleware("http")
async def log_middle(request: Request, call_next):
    start = time.perf_counter()
    response = await call_next(request)
    end = time.perf_counter()
    process_time = f"{(end - start) * 1000:0.1f} ms"
    logger.debug("{} {} {}", request.method, request.url, process_time)
    response.headers["X-Process-Time"] = process_time
    return response


# Startup and shutdown events
@app.on_event("startup")
async def startup_event():
    cog_client.start()


@app.on_event("shutdown")
async def shutdown_event():
    await cog_client.stop()


# Handle http exceptions from upstream server
@app.exception_handler(HTTPError)
async def upstream_http_exception_handler(request, exc: HTTPError):
    logger.warning(f"Upstream HTTP error [{request.query_params['url']}]: {repr(exc)}")
    # Convert to FastApi exception
    exc = HTTPException(502, f"Upstream server returned: [{exc.status}] {exc.message}")
    return await http_exception_handler(request, exc)


# Handle range request not supported exceptions
@app.exception_handler(HTTPRangeNotSupportedError)
async def upstream_range_not_supported_exception_handler(request, exc: HTTPError):
    logger.warning(
        f"Upstream server does not support range requests: [{request.query_params['url']}]"
    )
    # Convert to FastApi exception
    exc = HTTPException(502, f"Upstream server does not support http range requests")
    return await http_exception_handler(request, exc)


# Handle tiff exceptions
@app.exception_handler(TIFFError)
async def upstream_tiff_exception_handler(request, exc: TIFFError):
    logger.warning(
        f"Tiff error when reading [{request.query_params['url']}]: {repr(exc)}"
    )
    # Convert to FastApi exception
    exc = HTTPException(500, f"Error reading upstream tiff file: {exc.message}")
    return await http_exception_handler(request, exc)


# Handle http timeout exceptions
@app.exception_handler(TimeoutError)
async def upstream_timeout_exception_handler(request, exc: TIFFError):
    logger.warning(f"Timeout when reading [{request.query_params['url']}]: {repr(exc)}")
    # Convert to FastApi exception
    exc = HTTPException(504, f"Timeout getting upstream tiff file data")
    return await http_exception_handler(request, exc)


app.mount("/demo", StaticFiles(directory="demo_client"), name="demo")

########################################################################################
# cog endpoint generally follows this form:

# Return binary content from fastapi https://stackoverflow.com/a/67497103
"""
@app.get(
    "/cog",
    # Set what the media type will be in the autogenerated OpenAPI specification.
    # fastapi.tiangolo.com/advanced/additional-responses/#additional-media-types-for-the-main-response
    responses={200: {"content": {"image/jpeg": {}}}},
    # Prevent FastAPI from adding "application/json" as an additional
    # response media type in the autogenerated OpenAPI specification.
    # https://github.com/tiangolo/fastapi/issues/3258
    response_class=Response,
)
async def get_cog(
    z: int,
    x: int,
    y: int,
    overflow: Overflow = Overflow.Pad,
    cog: COGTiff = Depends(cog_client.cog_from_query_param),
):
    return await cog_client.get_tile_response(cog, z, x, y, overflow)
"""

########################################################################################
# image metadata


@app.get("/info", response_model=TiffInfo)
async def get_info(cog: COGTiff = Depends(cog_client.cog_from_query_param)):
    """Gets info about the internal layout of the specified Cloud Optimized GeoTIFF.

    - `width` full resolution tiff width in pixels
    - `height` full resolution tiff height in pixels
    - `tile_width` width of tiff tiles in pixels
    - `tile_height` height of tiff tiles in pixels
    - `tile_cols` number of tile columns in full resolution
    - `tile_rows` number of tile rows in full resolution
    - `overviews` number of reduced resolution overviews (excluding full resolution)
    """
    return await cog.get_info(0)


########################################################################################
# thumbnail endpoint


@app.get(
    "/thumbnail.jpg",
    responses={200: {"content": {"image/jpeg": {}}}},
    response_class=Response,
)
async def get_thumbnail(cog: COGTiff = Depends(cog_client.cog_from_query_param)):
    """Gets a thumbnail from the specified JPEG compressed Cloud Optimized GeoTIFF.

    This is equivalent to getting the top most tile from the overviews `(z=0, x=0, y=0)` using `overflow = crop`.
    The size of the returned thumbnail is generally undefined, but it cannot be larger than
    `tile_width` and `tile_height`."""
    info = await cog.get_info(0)
    max_zoom = info.overviews
    return await cog_client.get_tile_response(
        cog, max_zoom, 0, 0, overflow=Overflow.Crop
    )


########################################################################################
# xyz tiles endpoint
overflow_description = """What should happen with edge tiles when the image dimensions are not a multiple of the tile size.

`pad` pads the image with random data. This option requires the least amount of resources from the server and is therefore the fastest. All tiles will have the same dimensions.

`crop` crops the tiles that are not entirely filled by source image data. Edge tiles will have different dimensions from tiles completely covered by the source image.

`mask` masks the part of the tile which is outside the source image with black pixels. All tiles will have the same dimensions.
"""


@app.get(
    "/tiles/{z}/{x}/{y}.jpg",
    responses={200: {"content": {"image/jpeg": {}}}},
    response_class=Response,
)
async def get_tile_from_xyz(
    z: int = Path(..., description="Overview level (top most is `z=0`)"),
    x: int = Path(..., description="Tile column (from left side of image)"),
    y: int = Path(..., description="Tile row (from top of image)"),
    overflow: Overflow = Query(Overflow.Mask, description=overflow_description),
    cog: COGTiff = Depends(cog_client.cog_from_query_param),
):
    """Gets a single tile from the specified JPEG compressed Cloud Optimized GeoTIFF"""
    info = await cog.get_info(0)
    zoomlevels = info.overviews + 1
    cog_z = zoomlevels - z - 1
    return await cog_client.get_tile_response(cog, cog_z, x, y, overflow)


########################################################################################
# deepzoom
@app.get(
    "/deepzoom.dzi",
    responses={200: {"content": {"application/xml": {}}}},
    response_class=Response,
)
async def get_deepzoom_xml(cog: COGTiff = Depends(cog_client.cog_from_query_param)):
    """Deep Zoom endpoint"""
    info = await cog.get_info(0)
    xml = f"""<?xml version="1.0" encoding="utf-8"?>
                    <Image TileSize="{info.tile_width}" Rotation="0" Overlap="0" Format="jpg" ServerFormat="Default" xmlns="http://schemas.microsoft.com/deepzoom/2009">
                        <Size Width="{info.width}" Height="{info.height}"  />
                    </Image>"""
    return Response(content=xml, media_type="application/xml")


@app.get(
    "/deepzoom_files/{z}/{tilename}",
    responses={200: {"content": {"image/jpeg": {}}}},
    response_class=Response,
)
async def get_deepzoom_tile(
    z: int, tilename: str, cog: COGTiff = Depends(cog_client.cog_from_query_param)
):
    """Deep Zoom image tiles"""
    # TODO: regex p√• tile i FastAPI. TROR det er ("x_y.jpg")
    x, y = map(int, tilename[:-4].split("_"))
    # DeepZoom uses inverted z
    info = await cog.get_info(0)
    # https://github.com/openzoom/deepzoom.py/blob/master/deepzoom/__init__.py#L121
    max_dimension = max(info.width, info.height)
    num_levels = int(math.ceil(math.log(max_dimension, 2))) + 1
    cog_z = num_levels - z - 1
    # DeepZoom apparantly crops overflow away from tiles
    return await cog_client.get_tile_response(cog, cog_z, x, y, Overflow.Crop)


########################################################################################
# html viewer


@app.get(
    "/viewer.html",
    response_class=HTMLResponse,
)
async def get_html_viewer(cog_req: CogRequest = Depends(CogRequest)):
    """Interactive image viewer

    **Note**: Exposes token in html source"""
    token = cog_req.get_token()
    token_param = f"&token={token}" if token else ""
    html = f"""
<html>
<head>
<title>{cog_req.url}</title>
</head>
<body>
    <div id="openseadragon1" style="width: 1024px; height: 800px;"></div>
    <div id="metadata" style="width: 1024px; background-color: gainsboro;"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/openseadragon/3.0.0/openseadragon.min.js"></script>
    <script type="text/javascript">
        var encoded_url = encodeURIComponent("{cog_req.url}");
        var viewer = OpenSeadragon({{
            id: "openseadragon1",
            prefixUrl: "https://cdnjs.cloudflare.com/ajax/libs/openseadragon/3.0.0/images/",
            tileSources: "./deepzoom.dzi?url=" + encoded_url + "{token_param}"
        }});
    </script>
</body>
</html>"""
    return HTMLResponse(html)


########################################################################################
# helper methods
